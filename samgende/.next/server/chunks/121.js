"use strict";exports.id=121,exports.ids=[121],exports.modules={3186:(e,t,i)=>{i.d(t,{a:()=>s});var o=i(5036),n=i(5904),a=i.n(n);function s(e){return{...e,Image:e=>o.jsx(a(),{...e})}}},8167:(e,t,i)=>{/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var o=i(2),n=Symbol.for("react.element"),a=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,r=o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function c(e,t,i){var o,a={},c=null,d=null;for(o in void 0!==i&&(c=""+i),void 0!==t.key&&(c=""+t.key),void 0!==t.ref&&(d=t.ref),t)s.call(t,o)&&!l.hasOwnProperty(o)&&(a[o]=t[o]);if(e&&e.defaultProps)for(o in t=e.defaultProps)void 0===a[o]&&(a[o]=t[o]);return{$$typeof:n,type:e,key:c,ref:d,props:a,_owner:r.current}}t.Fragment=a,t.jsx=c,t.jsxs=c},9698:(e,t,i)=>{e.exports=i(8167)},7e3:(e,t,i)=>{i.d(t,{B:()=>r});var o=i(6843);let n=(0,o.createProxy)(String.raw`/Users/samgende/samGende.github.io/samgende/src/components/ArticleLayout.tsx`),{__esModule:a,$$typeof:s}=n;n.default;let r=(0,o.createProxy)(String.raw`/Users/samgende/samGende.github.io/samgende/src/components/ArticleLayout.tsx#ArticleLayout`)},2121:(e,t,i)=>{i.r(t),i.d(t,{article:()=>s,default:()=>d,metadata:()=>r});var o=i(9698),n=i(3186),a=i(7e3);let s={author:"Sam Gende",date:"2024-02-14",title:"Decision function of Support Vector Machines",description:"How do we choose a class?"},r={title:s.title,description:s.description},l=e=>o.jsx(a.B,{article:s,...e});function c(e){let t={p:"p",...(0,n.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[o.jsx(t.p,{children:"A common machine learning problem is having a set of data that needs to be split into two classes. One way to do this is using a support vector machine. For starters we need to define what the data and labels for the classes look like. This is relatively flexible when it comes to SVMs the individual data points just need to be vectors of the same dimension. The labels are more restrictive in that there can only be two classes into which the points can be classified as."}),"\n",o.jsx(t.p,{children:"We will first consider the 2d space since it is visually the easiest to digest, this means each of our data points will be a vector with the first number being the x coordinate and the second being a y coordinate. These will then be labeled with the class labels 1 or -1."}),"\n",o.jsx(t.p,{children:"Now we can jump into how a SVM actually works, the goal is to properly classify all of our points. We can do this with a decision function. This function will take in a point x from n^2 and output a class label 1 or -1. We can define this function as d(x) = w xT + b here w from n^2 and b from n are parameters that we can calculate to get an optimal decision function. In the function we take the dot product of w and x then add a bias b to get the output. With this definition we have one problem, the output is not always 1 or -1 to solve this we simply take the sign of the output and return 1 if the result is positive and -1 if it is negative. With this function an SVM can classify a new point into labels 1 or â€“1. Now we need to calculate an optimal w and b for the decision function this will be covered in the next article."})]})}function d(e={}){return o.jsx(l,{...e,children:o.jsx(c,{...e})})}}};